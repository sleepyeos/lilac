#Lilac

A lightweight, minimalist library designed to make developing C applications on Linux easier. It contains components for exception handling, unit/integration testing, and garbage collection.

##Garbage Collector
Lilac GC is a conservative mark-and-sweep collector. Its usage is very simple:
```
#include "lilac.h"
#include <stdio.h>

int main(int argc, char *argv[]) {

    /*Initialize the GC with the argv pointer.
     *This is done so Lilac can find the end of
     *the stack.
     */
    init_gc(argv);

    /*Optionally set the threshold for the GC to
     *start collecting. The value is in megabytes;
     *default is 10 MB
     */
     update_gc_threshold(1);

    /*Allocate memory using lilac_malloc(),
     *lilac_calloc(), and lilac_realloc().
     *These functions have the same interface
     *as standard malloc(), calloc(), and realloc().
     *
     *Anything allocated with these functions will
     *be automatically garbage collected as your
     *application runs.
     */
    int *a = lilac_malloc(sizeof(int));
    *a = 31415;
    printf("*a = %d", *a);
}
```

##Exception Handling
Lilac can also be utilized for C++-style exception handling. This is implemented as a set of 4 macros in `exceptions.h`. Their usage is as follows:
```
#include "exceptions.h"

int main(void) {
    try {
        //Error-prone code
        printf("Before throw()\n");
      	throw();
        printf("After throw()\n");
    } catch {
        //Handle the exception
        printf("[!] Exception caught\n");
    } finally {
        //Clean up and finalize	
        printf("Finally block executed\n");
    }
}

```
Output:
```
Before throw()
[!] Exception caught
Finally block executed
```
This is an *extremely* minimalist implementation -- simply syntactic sugar for setjmp() and longjmp(); Exceptions will not be propagated up the stack, and specific/custom exception types are not supported. This is in the interest of keeping Lilac as simplistic and lightweight as possible. Take care to only use dynamic memory allocated by Lilac when using these macros; using automatic variables can cause issues when using setjmp()/longjmp().

##Unit/Integration Testing
Lilac's automated testing framework, like the exception handling component, is built as a set of macros.
This component was inspired by [Minunit](http://www.jera.com/techinfo/jtns/jtn002.html) and expanded to suit my own needs. It is composed of just three C preprocessor macros in a single header file. Their usage works as follows:

**program.c**
```
#include "program.h"

int add(int x, int y) {
    return x + y;
}
```

**test_program.c**
```
#include <stdint.h>
#include <stdio.h>
#include "test.h"

// Include the full source file instead of just the header if you intend to test static methods as well
#include "program.h"

// Each test returns uint8_t*. 0 will be returned if there are no errors, else an error message
// generated by li_assert will be returned and printed by li_run_test.p
static uint8_t *test_add() {
       li_assert(add(49,51) == 100);
       return 0;
}

// Run each test from a function with this exact signature; it's used by the macro li_run_suite.
static uint8_t *all_tests() {
       li_run_test(test_add);
       return 0;
}

// The main method needs only to call the li_run_suite macro and give it a name to use for the
// test suite in the status output. The macro will return 0 on success and non-zero on failure.
int main(void) {
    li_run_suite("Program.c");
}
```

###Output from above example:
```
[+] Testing Program.c...
  [!] Running test 1: test_add
      [+] assert 1: add(49, 51) == 100
[+] Program.c tests OK
Tests run: 1
      
```